<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Language" content="en-us" />

		<title>Django | 生成查询 | Django文档</title>

		<meta name="ROBOTS" content="ALL" />
		<meta http-equiv="imagetoolbar" content="no" />
		<meta name="MSSmartTagsPreventParsing" content="true" />
		<meta name="Copyright" content="This site's design and contents Copyright (c) 2005  Lawrence Journal-World." />

		<meta name="keywords" content="Python, Django, framework, open-source" />
		<meta name="description" content="Django是一个高级的python网站框架，它简洁实用，广受好评，发展迅速。" />

		<link href="http://media.djangoproject.com/css/base.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="http://media.djangoproject.com/css/print.css" rel="stylesheet" type="text/css" media="print" />
      
  
  <style type="text/css" media="screen">
    #docs-search {
      color: #000;
      float: right;
    }
    #docs-search form {
      font-size: 92%;
      margin: 0;
      padding: 1em 1em 0;
      white-space: nowrap;
    }
    form.search ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    form.search li {
      display: inline;
      padding-right: 1em;
    }
    form.search .query {
      width: 18em;
    }
  </style>
  <link rel="stylesheet" href="http://media.djangoproject.com/css/pygments.css" type="text/css" />

	</head>

	<body id="documentation" class="default">

	<div id="container">
		<div id="header">
			<h1 id="logo"><a href="http://www.djangoproject.com/"><img src="http://media.djangoproject.com/img/site/hdr_logo.gif" alt="Django" /></a></h1>
			<ul id="nav-global">
				<li id="nav-homepage"><a href="http://www.djangoproject.com/">Home</a></li>
				<li id="nav-download"><a href="http://www.djangoproject.com/download/">Download</a></li>
				<li id="nav-documentation"><a href="http://docs.djangoproject.com/">Documentation</a></li>
				<li id="nav-weblog"><a href="http://www.djangoproject.com/weblog/">Weblog</a></li>
				<li id="nav-community"><a href="http://www.djangoproject.com/community/">Community</a></li>
				<li id="nav-code"><a href="http://code.djangoproject.com/">Code</a></li>
			</ul>
		</div>
		<!-- END Header -->
		<div id="billboard">
  <h2><a href="../../../index.html">Django 文档</a></h2>
</div>
		<div id="columnwrap">
			
		<div id="content-main">
		


  <h2 class="deck">
  
        当前文档仅适用于 Django SVN 版本，与上个版本有显著不同。上个版本文档请查阅
      <a href="http://docs.djangoproject.com/en/1.0/topics/db/queries/">Django 1.0</a>
  
  </h2>
  <div class="section" id="s-making-queries">
<span id="s-topics-db-queries"></span><span id="making-queries"></span><span id="topics-db-queries"></span><h1>制作查询 (Making queries)<a class="headerlink" href="index.html#making-queries" title="Permalink to this headline">¶</a></h1>
<p>创建完<a class="reference external" href="../models/index.html#topics-db-models"><em>数据模型data models)</em></a> 之后, Django 自动为你提供一套数据库抽象层的API，利用它可以完成创建，提取，更新，删除对象的操作。本文介绍如何使用这些API。关于查询时用到的参数，请查阅 <a class="reference external" href="../../../ref/models/index.html#ref-models-index"><em>数据模型参考 (data model reference)</em></a> 。</p>
<p>在整个文档以及引用的文档中中，我们都将以下面这个博客为例( Blog 是博客站点，Author 是博客作者，Entry 是博客文章，在下文中我们分别以博客，作者，博文相称):</p>
<div class="highlight-python" id="queryset-model-example"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mf">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mf">50</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mf">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">()</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">n_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">n_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
<div class="section" id="s-creating-objects">
<span id="creating-objects"></span><h2>创建对象 (Creating objects)<a class="headerlink" href="index.html#creating-objects" title="Permalink to this headline">¶</a></h2>
<p>Django 用一种很直观的表达方式将 Python 对象和数据表对应起来：一个 model 类对应一张数据表，一个 model 实例对应表中的某一行记录。</p>
<p>以创建对象为例：只要将关键字参数传递给 model 类，然后调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 保存到数据库即可。</p>
<p>正如你所期望的那样，你可以根据 model 类所在的路径将 model 类导入到当前文件中（之所以强调这一点，是因为上一版本的 django 在导入 model 这方面做得并不好。）</p>
<p>假设所有 model 都在文件 <tt class="docutils literal"><span class="pre">mysite/blog/models.py</span></tt>中, 那么在下面这个例子中:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mysite.blog.models</span> <span class="k">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Beatles Blog&#39;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">&#39;All the latest Beatles news.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>这段代码就会在幕后执行一条 <tt class="docutils literal"><span class="pre">INSERT</span></tt> SQL 语句。除非你显式地调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法，否则 Django 不会保存到数据库中。</p>
<p> <tt class="docutils literal"><span class="pre">save()</span></tt> 方法不返回任何值。</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">请参见</p>
<p><tt class="docutils literal"><span class="pre">save()</span></tt> 方法自带一些高级参数，这里并没有提及。
详见 <tt class="docutils literal"><span class="pre">save()</span></tt> 的文档。</p>
<p class="last">你可以使用 <tt class="docutils literal"><span class="pre">`create()`</span></tt>
方法一次完成新建并保存对象的操作。</p>
</div>
</div>
<div class="section" id="s-saving-changes-to-objects">
<span id="saving-changes-to-objects"></span><h2>保存对象修改后的信息 (Saving changes to objects)<a class="headerlink" href="index.html#saving-changes-to-objects" title="Permalink to this headline">¶</a></h2>
<p>对于已经存在于数据库中的对象，要保存修改后的信息，仍是使用 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法。</p>
<p>假设现在有一个 <tt class="docutils literal"><span class="pre">Blog</span></tt> 类的实例 <tt class="docutils literal"><span class="pre">b5</span></tt> ，它已经保存到数据库中，下面的例子将改变它的名称，然后更新到数据库中：</p>
<div class="highlight-python"><pre>&gt;&gt; b5.name = 'New name'
&gt;&gt; b5.save()</pre>
</div>
<p>这段代码在幕后执行一条 <tt class="docutils literal"><span class="pre">UPDATE</span></tt> SQL 语句。除非你显式地调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法，否则 Django 不会更新数据库。</p>
<div class="section" id="s-saving-foreignkey-and-manytomanyfield-fields">
<span id="saving-foreignkey-and-manytomanyfield-fields"></span><h3>保存 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 和 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 字段 (Saving ForeignKey and ManyToManyField fields)<a class="headerlink" href="index.html#saving-foreignkey-and-manytomanyfield-fields" title="Permalink to this headline">¶</a></h3>
<p>更新 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 字段和保存普通字段没什么差别；只是在给字段分配对象时要注意对象类型一定要正确：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Cheddar Talk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>更新 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 就有些不同；要在字段上使用 <tt class="docutils literal"><span class="pre">add()</span></tt>
方法来添加关系：</p>
<div class="highlight-python"><pre>&gt;&gt; joe = Author.objects.create(name="Joe")
&gt;&gt; entry.authors.add(joe)</pre>
</div>
<p>如果你在分配或添加对象时，使用了类型错误的对象，Django就会报错。</p>
</div>
</div>
<div class="section" id="s-retrieving-objects">
<span id="retrieving-objects"></span><h2>检索对象 (Retrieving objects)<a class="headerlink" href="index.html#retrieving-objects" title="Permalink to this headline">¶</a></h2>
<p>要检索数据库中的对象，就要为你的 model 类构造一个 <tt class="docutils literal"><span class="pre">查询集 (QuerySet)</span></tt> 或 <tt class="docutils literal"><span class="pre">Manager</span></tt> 。</p>
<p>一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 就代表数据库中的一组数据。它可以有一个或很多个，也可以没有<em>过滤器(filter)</em>--根据给定的参数对数据集做进一步筛选。在 SQL 术语中， <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 相当于 <tt class="docutils literal"><span class="pre">SELECT</span></tt>
语句，filter 相当于 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 或 <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 这样的限定从句。</p>
<p>你可以利用 model 的 <tt class="docutils literal"><span class="pre">Manager</span></tt> 来得到 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 。每个 model 都有至少一个 <tt class="docutils literal"><span class="pre">Manager</span></tt>，默认情况下它被命名为 <tt class="docutils literal"><span class="pre">objects</span></tt> 。你可以直接通过 model 类来访问 objects ，如下例所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Foo&#39;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">&#39;Bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager isn&#39;t accessible via Blog instances.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p class="last"><tt class="docutils literal"><span class="pre">Managers</span></tt> 只能由 model 类访问，而不能通过 model 实例访问。这是因为前者是表级操作，而后者只是记录级操作。</p>
</div>
<p> <tt class="docutils literal"><span class="pre">Manager</span></tt> 是 model 中主要的 <tt class="docutils literal"><span class="pre">QuerySets</span></tt> 。 它相当于一个&quot;根&quot; <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，用来描述数据库中所有对象。例如，<tt class="docutils literal"><span class="pre">Blog.objects</span></tt> 是包含数据表中所有 <tt class="docutils literal"><span class="pre">Blog</span></tt> 对象的初始 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 。</p>
<div class="section" id="s-retrieving-all-objects">
<span id="retrieving-all-objects"></span><h3>检索所有对象 (Retrieving all objects)<a class="headerlink" href="index.html#retrieving-all-objects" title="Permalink to this headline">¶</a></h3>
<p>从表中检索对象的最简单方式就是一次得到所有对象，只要调用 <tt class="docutils literal"><span class="pre">Manager</span></tt> 的 <tt class="docutils literal"><span class="pre">all()</span></tt> 方法即可:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p> <tt class="docutils literal"><span class="pre">all()</span></tt> 方法返回一个表示数据表中所有对象的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。</p>
<p>( <tt class="docutils literal"><span class="pre">Entry.objects</span></tt> 也是一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，为什么我们不直接使用 <tt class="docutils literal"><span class="pre">Entry.objects</span></tt> 呢?
这是因为 <tt class="docutils literal"><span class="pre">Entry.objects</span></tt> 是特殊的根 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，它<b>不能</b>被求值；而 <tt class="docutils literal"><span class="pre">all()</span></tt> 方法则返回一个<b>可以</b>被求值的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。)</p>
</div>
<div class="section" id="s-retrieving-specific-objects-with-filters">
<span id="retrieving-specific-objects-with-filters"></span><h3>使用过滤器检索特定的对象 (Retrieving specific objects with filters)<a class="headerlink" href="index.html#retrieving-specific-objects-with-filters" title="Permalink to this headline">¶</a></h3>
<p> <tt class="docutils literal"><span class="pre">Manager</span></tt> 提供的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 描述了数据表中的所有对象。但通常情况下，你需要的只是数据集中的某个子集。</p>
<p>你可以添加筛选条件来缩小初始 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的范围，从而获得数据子集。筛选 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 最常用的两种方式是:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">filter(**kwargs)</span></tt></dt>
<dd>返回<b>满足</b>筛选条件的新 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。</dd>
<dt><tt class="docutils literal"><span class="pre">exclude(**kwargs)</span></tt></dt>
<dd>返回<b>不满足</b>筛选条件的新 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。</dd>
</dl>
<p>这些筛选条件 (就是上述函数定义中的 <tt class="docutils literal"><span class="pre">**kwargs</span></tt> ) 在下面的 <a class="reference internal" href="index.html#field-lookups">字段筛选条件 (Field lookups)</a> 中有详细的介绍</p>
<p>举个例子，用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 检索2006年发布的所有博文 ，可以使用 <tt class="docutils literal"><span class="pre">filter()</span></tt> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2006</span><span class="p">)</span>
</pre></div>
</div>
<p>不必添加 <tt class="docutils literal"><span class="pre">all()</span></tt> -- <tt class="docutils literal"><span class="pre">Entry.objects.all().filter(...)</span></tt>。要从根 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 得到所有对象，才适用 <tt class="docutils literal"><span class="pre">all()</span></tt> 方法。</p>
<div class="section" id="s-id1">
<span id="s-chaining-filters"></span><span id="id1"></span><span id="chaining-filters"></span><h4>链式过滤 (Chaining filters)<a class="headerlink" href="index.html#id1" title="Permalink to this headline">¶</a></h4>
<p>筛选后得到 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 仍是一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，所以可以构造过滤链。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">headline__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码用初始 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 获得数据表中所有记录，然后依次添加 filter ，exclude ，filter 三个过滤。最终得到的结果是一个新 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，它包含了大标题以&quot;What&quot;开头，并从2005年1月1日到目前为止出版的所有记录。</p>
</div>
<div class="section" id="s-id2">
<span id="s-filtered-querysets-are-unique"></span><span id="id2"></span><span id="filtered-querysets-are-unique"></span><h4>过滤后的查询集是唯一的 (Filtered querysets unique)<a class="headerlink" href="index.html#id2" title="Permalink to this headline">¶</a></h4>
<p>每次筛选 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>后，都返回一个新的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。它与前一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>完全不同。每次筛选都创建一个独立而不同的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>。它可以保存，可以使用而且可以多次使用的。</p>
<p>例如：</p>
<div class="highlight-python"><pre>&gt;&gt; q1 = Entry.objects.filter(headline__startswith="What")
&gt;&gt; q2 = q1.exclude(pub_date__gte=datetime.now())
&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.now())</pre>
</div>
<p>这三个 <tt class="docutils literal"><span class="pre">QuerySets</span></tt> 是不同的。 第一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 包含大标题以&quot;What&quot;开头的所有记录。第二个则是第一个的子集，用一个附加的条件排除了出版日期 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 是今天的记录。 第三个也是第一个的子集，它只保留出版日期 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 是今天的记录。 最初的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> (<tt class="docutils literal"><span class="pre">q1</span></tt>) 没有受到筛选的影响。</p>
</div>
<div class="section" id="s-id3">
<span id="s-querysets-are-lazy"></span><span id="id3"></span><span id="querysets-are-lazy"></span><h4>查询集是惰性的 (QuerySets are lazy)<a class="headerlink" href="index.html#id3" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">QuerySets</span></tt> 是惰性的 -- 创建 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的动作不涉及任何数据库操作。你可以一直添加过滤器，在这个过程中，Django 不会执行任何数据库查询，除非 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> <b>被执行</b>. 看看下面这个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s">&quot;food&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">q</span>
</pre></div>
</div>
<p>虽然上面的代码看上去象是三个数据库操作，但实际上只在最后一行 (<tt class="docutils literal"><span class="pre">print</span> <span class="pre">q</span></tt>) 执行了一次数据库操作，。一般情况下， <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 不能从数据库中主动地获得数据，得被动地由你来请求。对 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 求值就意味着 Django 会访问数据库。想了解对查询集何时求值，请查看 <a class="reference external" href="../../../ref/models/querysets/index.html#when-querysets-are-evaluated"><em>何时对查询集求值 (When QuerySets are evaluated)</em></a>.</p>
</div>
<div class="section" id="s-other-queryset-methods">
<span id="other-queryset-methods"></span><h4>其他查询集方法 (Other querysets mothods)<a class="headerlink" href="index.html#other-queryset-methods" title="Permalink to this headline">¶</a></h4>
<p>大多数情况使用 <tt class="docutils literal"><span class="pre">all()</span></tt>, <tt class="docutils literal"><span class="pre">filter()</span></tt> 和 <tt class="docutils literal"><span class="pre">exclude()</span></tt> 就足够了。 但也有一些不常用的；请查看 <a class="reference external" href="../../../ref/models/querysets/index.html#queryset-api"><em>查询API参考 (QuerySet API Reference)</em></a> 中完整的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 方法列表。</p>
</div>
</div>
<div class="section" id="s-id4">
<span id="s-limiting-querysets"></span><span id="id4"></span><span id="limiting-querysets"></span><h3>限制查询集范围 (Limiting QuerySets)<a class="headerlink" href="index.html#id4" title="Permalink to this headline">¶</a></h3>
<p>可以用 python 的数组切片语法来限制你的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 以得到一部分结果。它等价于SQL中的 <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 和 <tt class="docutils literal"><span class="pre">OFFSET</span></tt> 。</p>
<p>例如，下面的这个例子返回前五个对象 (<tt class="docutils literal"><span class="pre">LIMIT</span> <span class="pre">5</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mf">5</span><span class="p">]</span>
</pre></div>
</div>
<p>这个例子返回第六到第十之间的对象 (<tt class="docutils literal"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mf">5</span><span class="p">:</span><span class="mf">10</span><span class="p">]</span>
</pre></div>
</div>
<p>Django 不支持对查询集做负数索引 (例如 <tt class="docutils literal"><span class="pre">Entry.objects.all()[-1]</span></tt>) 。</p>
<p>一般来说，对 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 切片会返回新的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> -- 这个过程中不会对运行查询。不过也有例外，如果你在切片时使用了 &quot;step&quot; 参数，查询集就会被求值，就在数据库中运行查询。举个例子，使用下面这个这个查询集返回前十个对象中的偶数次对象，就会运行数据库查询:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mf">10</span><span class="p">:</span><span class="mf">2</span><span class="p">]</span>
</pre></div>
</div>
<p>要检索<b>单独</b>的对象，而非列表 (比如 <tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></tt>)，可以直接使用索引来代替切片。举个例子，下面这段代码将返回大标题排序后的第一条记录 <tt class="docutils literal"><span class="pre">Entry</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>
</pre></div>
</div>
<p>大约等价于：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)[</span><span class="mf">0</span><span class="p">:</span><span class="mf">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>要注意的是：如果找不到符合条件的对象，第一种方法会抛出 <tt class="docutils literal"><span class="pre">IndexError</span></tt> ，而第二种方法会抛出 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt>。 详看 <tt class="docutils literal"><span class="pre">get()</span></tt> 。</p>
</div>
<div class="section" id="s-field-lookups">
<span id="s-field-lookups-intro"></span><span id="field-lookups"></span><span id="field-lookups-intro"></span><h3>字段筛选条件 (Field lookups)<a class="headerlink" href="index.html#field-lookups" title="Permalink to this headline">¶</a></h3>
<p>字段筛选条件就是 SQL 语句中的 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 从句。就是 Django 中的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">filter()</span></tt>,
<tt class="docutils literal"><span class="pre">exclude()</span></tt> 和 <tt class="docutils literal"><span class="pre">get()</span></tt> 方法中的关键字参数。</p>
<p>筛选条件的形式是 <tt class="docutils literal"><span class="pre">field__lookuptype=value</span></tt> 。
(注意：这里是双下划线)。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s">&#39;2006-01-01&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>大体可以翻译为如下的 SQL 语句:</p>
<div class="highlight-python"><pre>SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';</pre>
</div>
<div class="admonition-how-this-is-possible admonition ">
<p class="first admonition-title">这是怎么办到的？</p>
<p class="last">Python 允许函式接受任意多 name-value 形式的参数，并在运行时才确定name和value的值。详情请参阅官方Python教程中的 <a class="reference external" href="http://docs.python.org/tut/node6.html#SECTION006720000000000000000">关键字参数(Keyword Arguments)</a>。</p>
</div>
<p>如果你传递了一个无效的关键字参数，会抛出 <tt class="docutils literal"><span class="pre">TypeError</span></tt> 导常。</p>
<p>数据库 API 支持<b>24</b>种查询类型；可以在 <a class="reference external" href="../../../ref/models/querysets/index.html#field-lookups"><em>字段筛选参考(field lookup reference)</em></a> 查看详细的列表。为了给您一个直观的认识，这里我们列出一些常用的查询类型：</p>
<dl class="docutils">
<dt><tt class="xref docutils literal"><span class="pre">exact</span></tt></dt>
<dd><p class="first"> &quot;exact&quot; 匹配。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s">&quot;Man bites dog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>会生成如下的 SQL 语句：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="o">=</span> <span class="s1">&#39;Man bites dog&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>如果你没有提供查询类型 -- 也就是说关键字参数中没有双下划线，那么查询类型就会被指定为 <tt class="docutils literal"><span class="pre">exact</span></tt>。</p>
<p>举个例子，这两个语句是相等的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span>  <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span>         <span class="c"># __exact is implied</span>
</pre></div>
</div>
<p class="last">这样做很方便，因为 <tt class="docutils literal"><span class="pre">exact</span></tt> 是最常用的。</p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">iexact</span></tt></dt>
<dd><p class="first">忽略大小写的匹配。所以下面的这个查询:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">&quot;beatles blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">会匹配标题是 &quot;Beatles Blog&quot;, &quot;beatles blog&quot;, 甚至 &quot;BeAtlES blOG&quot; 的 <tt class="docutils literal"><span class="pre">Blog</span></tt> </p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">contains</span></tt></dt>
<dd><p class="first">大小写敏感的模糊匹配。 例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>大体可以翻译为如下的 SQL：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>要注意这段代码匹配大标题 <tt class="docutils literal"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></tt> ，而不能匹配 <tt class="docutils literal"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></tt>。</p>
<p class="last">它也有一个忽略大小写的版本，就是 <tt class="xref docutils literal"><span class="pre">icontains</span></tt>。</p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">startswith</span></tt>, <tt class="xref docutils literal"><span class="pre">endswith</span></tt></dt>
<dd>分别匹配开头和结尾，同样也有忽略大小写的版本 <tt class="xref docutils literal"><span class="pre">istartswith</span></tt> 和
<tt class="xref docutils literal"><span class="pre">iendswith</span></tt>。</dd>
</dl>
<p>再强调一次，这仅仅是简短介绍。完整的参考请参见 <a class="reference external" href="../../../ref/models/querysets/index.html#field-lookups"><em>字段筛选条件参考(field lookup reference)</em></a>。</p>
</div>
<div class="section" id="s-lookups-that-span-relationships">
<span id="lookups-that-span-relationships"></span><h3>跨关系查询 (Lookups that span relationships)<a class="headerlink" href="index.html#lookups-that-span-relationships" title="Permalink to this headline">¶</a></h3>
<p>Django 提供了一种直观而高效的方式在查询(lookups)中表示关联关系，它能自动确认 SQL <tt class="docutils literal"><span class="pre">JOIN</span></tt> 联系。要做跨关系查询，就使用两个下划线来链接模型(model)间关联字段的名称，直到最终链接到你想要的 model 为止。</p>
<p>这个例子检索所有关联 <tt class="docutils literal"><span class="pre">Blog</span></tt> 的 <tt class="docutils literal"><span class="pre">name</span></tt> 值为 <tt class="docutils literal"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></tt> 的所有 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象：</p>

<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__exact</span><span class="o">=</span><span class="s">&#39;Beatles Blog&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>跨关系的筛选条件可以一直延展。</p>
<p>关系也是可逆的。可以在目标 model 上使用源 model 名称的小写形式得到反向关联。</p>
<p>下面这个例子检索至少关联一个 <tt class="docutils literal"><span class="pre">Entry</span></tt> 且大标题 <tt class="docutils literal"><span class="pre">headline</span></tt> 包含 <tt class="docutils literal"><span class="pre">'Lennon'</span></tt> 的所有 <tt class="docutils literal"><span class="pre">Blog</span></tt> 对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果在某个关联 model 中找不到符合过滤条件的对象，Django 将视它为一个空的 (所有的值都是 <tt class="docutils literal"><span class="pre">NULL</span></tt>), 但是可用的对象。这意味着不会有异常抛出，在这个例子中：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__author__name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(假设关联到 <tt class="docutils literal"><span class="pre">Author</span></tt> 类), 如果没有哪个 <tt class="docutils literal"><span class="pre">author</span></tt> 与 entry 相关联，Django 会认为它没有 <tt class="docutils literal"><span class="pre">name</span></tt> 属性，而不会因为不存在 <tt class="docutils literal"><span class="pre">author</span></tt> 抛出异常。通常来说，这正是你所希望的机制。唯一的例外是使用 <tt class="docutils literal"><span class="pre">isnull</span></tt> 的情况。如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__author__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码会得到 <tt class="docutils literal"><span class="pre">author</span></tt> 的 <tt class="docutils literal"><span class="pre">name</span></tt> 为空的 <tt class="docutils literal"><span class="pre">Blog</span></tt> 或 <tt class="docutils literal"><span class="pre">entry</span></tt> 的 <tt class="docutils literal"><span class="pre">author</span></tt>为空的 <tt class="docutils literal"><span class="pre">Blog</span></tt>。 如果不嫌麻烦，可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p"> (</span><span class="n">entry__author__isnull</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">entry__author__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-spanning-multi-valued-relationships">
<span id="spanning-multi-valued-relationships"></span><h4>跨一对多／多对多关系(Spanning multi-valued relationships)<a class="headerlink" href="index.html#spanning-multi-valued-relationships" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">这部分是Django 1.0中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本记录</em></a></div>
<p>如果你的过滤是基于 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 或是逆向 <tt class="docutils literal"><span class="pre">ForeignKeyField</span></tt> 的，你可能会对下面这两种情况感兴趣。回顾 <tt class="docutils literal"><span class="pre">Blog</span></tt>/<tt class="docutils literal"><span class="pre">Entry</span></tt> 的关系(<tt class="docutils literal"><span class="pre">Blog</span></tt> 到 <tt class="docutils literal"><span class="pre">Entry</span></tt> 是一对多关系)，如果要查找这样的 blog：它关联一个大标题包含<b>&quot;Lennon&quot;</b>，且在2008年出版的 entry ；或者要查找这样的 blogs：它关联一个大标题包含<b>&quot;Lennon&quot;</b>的 entry ，同时它又关联另外一个在2008年出版的 entry 。因为一个 <tt class="docutils literal"><span class="pre">Blog</span></tt> 会关联多个的<tt class="docutils literal"><span class="pre">Entry</span></tt>，所以上述两种情况在现实应用中是很有可能出现的。</p>
<p>同样的情形也出现在 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 上。例如，如果 <tt class="docutils literal"><span class="pre">Entry</span></tt> 有一个 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 字段，名字是 <tt class="docutils literal"><span class="pre">tags</span></tt>，我们想得到 tags 是<b>&quot;music&quot;</b>和<b>&quot;bands&quot;</b>的 <tt class="docutils literal"><span class="pre">entries</span></tt>，或者我们想得到包含名为<b>&quot;music&quot;</b> 的标签而状态是<b>&quot;public&quot;</b>的 <tt class="docutils literal"><span class="pre">entry</span></tt>。</p>
<p>针对这两种情况，Django 用一种很方便的方式来使用 <tt class="docutils literal"><span class="pre">filter()</span></tt> 和 <tt class="docutils literal"><span class="pre">exclude()</span></tt>。对于包含在同一个 <tt class="docutils literal"><span class="pre">filter()</span></tt> 中的筛选条件，查询集要同时满足所有筛选条件。而对于连续的 <tt class="docutils literal"><span class="pre">filter()</span></tt> ，查询集的范围是依次限定的。但对于跨一对多／多对多关系查询来说，在第二种情况下，筛选条件针对的是<b>主 model 所有的关联对象</b>，而不是被前面的 <tt class="docutils literal"><span class="pre">filter()</span></tt> 过滤后的关联对象。</p>
<p>这听起来会让人迷糊，举个例子会讲得更清楚。要检索这样的 blog：它要关系一个大标题中含有 <em>&quot;Lennon&quot;</em> 并且在2008年出版的 entry (这个 entry 同时满足这两个条件)，可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mf">2008</span><span class="p">)</span>
</pre></div>
</div>
<p>要检索另外一种 blog：它关联一个大标题含有<em>&quot;Lennon&quot;</em>的 entry ，又关联一个在2008年出版的 entry （一个 entry 的大标题含有 <b>Lennon</b>，同一个或另一个 entry 是在2008年出版的）。可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mf">2008</span><span class="p">)</span>
</pre></div>
</div>
<p>在第二个例子中，第一个过滤器(filter)先检索与符合条件的 entry 的相关联的所有 blogs。第二个过滤器在此基础上从这些 blogs 中检索与第二种 entry 也相关联的 blog。第二个过滤器选择的 entry 可能与第一个过滤器所选择的完全相同，也可能不同。 因为过滤项过滤的是 <tt class="docutils literal"><span class="pre">Blog</span></tt>，而不是 <tt class="docutils literal"><span class="pre">Entry</span></tt>。</p>
<p>上述原则同样适用于 <tt class="docutils literal"><span class="pre">exclude()</span></tt>：一个单独 <tt class="docutils literal"><span class="pre">exclude()</span></tt> 中的所有筛选条件都是作用于同一个实例 (如果这些条件都是针对同一个一对多／多对多的关系)。连续的 <tt class="docutils literal"><span class="pre">filter()</span></tt> 或 <tt class="docutils literal"><span class="pre">exclude()</span></tt> 却根据同样的筛选条件，作用于不同的关联对象。</p>
</div>
</div>
<div class="section" id="s-filters-can-reference-fields-on-the-model">
<span id="s-query-expressions"></span><span id="filters-can-reference-fields-on-the-model"></span><span id="query-expressions"></span><h3>在过滤器中引用 model 中的字段(Filters can reference fields on the model)<a class="headerlink" href="index.html#filters-can-reference-fields-on-the-model" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">这部分是 Django 1.1 新增的:</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本记录</em></a></div>
<p>在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？</p>
<p>Django 提供 <tt class="docutils literal"><span class="pre">F()</span></tt> 来做这样的比较。<tt class="docutils literal"><span class="pre">F()</span></tt> 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。</p>
<p>例如：要查询回复数(comments)大于广播数(pingbacks)的博文(blog entries)，可以构造一个 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象在查询中引用评论数量：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">n_pingbacks__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">&#39;n_comments&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Django 支持 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象之间以及 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象和常数之间的加减乘除和取模的操作。例如，要找到广播数等于评论数两倍的博文，可以这样修改查询语句：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">n_pingbacks__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">&#39;n_comments&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2</span><span class="p">)</span>
</pre></div>
</div>
<p>要查找阅读数量小于评论数与广播数之和的博文，查询如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">&#39;n_comments&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="s">&#39;n_pingbacks&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>你也可以在 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象中使用两个下划线做跨关系查询。<tt class="docutils literal"><span class="pre">F()</span></tt> 对象使用两个下划线引入必要的关联对象。例如，要查询博客(blog)名称与作者(author)名称相同的博文(entry)，查询就可以这样写：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">author__name</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="s-the-pk-lookup-shortcut">
<span id="the-pk-lookup-shortcut"></span><h3>主键查询的简捷方式 (The pk lookup shortcut)<a class="headerlink" href="index.html#the-pk-lookup-shortcut" title="Permalink to this headline">¶</a></h3>
<p>为使用方便考虑，Django 用 <tt class="docutils literal"><span class="pre">pk</span></tt> 代表主键&quot;primary key&quot;。</p>
<p>以 <tt class="docutils literal"><span class="pre">Blog</span></tt> 为例, 主键是 <tt class="docutils literal"><span class="pre">id</span></tt> 字段，所以下面三个语句都是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span> <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span> <span class="c"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mf">14</span><span class="p">)</span> <span class="c"># pk implies id__exact</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">pk</span></tt> 对 <tt class="docutils literal"><span class="pre">__exact</span></tt> 查询同样有效，任何查询项都可以用 <tt class="docutils literal"><span class="pre">pk</span></tt> 来构造基于主键的查询：</p>
<div class="highlight-python"><pre># Get blogs entries with id 1, 4 and 7
&gt;&gt;&gt; Blog.objects.filter(pk__in=[1,4,7])

# Get all blog entries with id &gt; 14
&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)</pre>
</div>
<p><tt class="docutils literal"><span class="pre">pk</span></tt> 查询也可以跨关系，下面三个语句是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span> <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>        <span class="c"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>        <span class="c"># __pk implies __id__exact</span>
</pre></div>
</div>
</div>
<div class="section" id="s-escaping-percent-signs-and-underscores-in-like-statements">
<span id="escaping-percent-signs-and-underscores-in-like-statements"></span><h3>在LIKE语句中转义百分号%和下划线_ (Escaping percent signs and underscores in LIKE statements)<a class="headerlink" href="index.html#escaping-percent-signs-and-underscores-in-like-statements" title="Permalink to this headline">¶</a></h3>
<p>字段筛选条件相当于 <tt class="docutils literal"><span class="pre">LIKE</span></tt> SQL 语句 (<tt class="docutils literal"><span class="pre">iexact</span></tt>,
<tt class="docutils literal"><span class="pre">contains</span></tt>, <tt class="docutils literal"><span class="pre">icontains</span></tt>, <tt class="docutils literal"><span class="pre">startswith</span></tt>, <tt class="docutils literal"><span class="pre">istartswith</span></tt>, <tt class="docutils literal"><span class="pre">endswith</span></tt> 和 <tt class="docutils literal"><span class="pre">iendswith</span></tt>) ，它会自动转义两个特殊符号 -- 百分号<b>%</b>和下划线<b>_</b>。(在 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 语句中，百分号<b>%</b>表示多字符匹配，而下划线<b>_</b>表示单字符匹配。)</p>
<p>这就意味着我们可以直接使用这两个字符，而不用考虑他们的 SQL 语义。例如，要查询大标题中含有一个百分号<b>%</b>的 entry：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;%&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Django 会处理转义；最终的 SQL 看起来会是这样：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%\%%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>下划线<b>_</b>和百分号<b>%</b>的处理方式相同，Django 都会自动转义。</p>
</div>
<div class="section" id="s-id5">
<span id="s-caching-and-querysets"></span><span id="id5"></span><span id="caching-and-querysets"></span><h3>缓存和查询 (Caching and QuerySets)<a class="headerlink" href="index.html#id5" title="Permalink to this headline">¶</a></h3>
<p>每个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 都包含一个缓存，以减少对数据库的访问。要编写高效代码，就要理解缓存是如何工作的。</p>
<p>一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时刚刚创建的时候，缓存是空的。 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 第一次运行时，会执行数据库查询，接下来 Django 就在 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的缓存中保存查询的结果，并根据请求返回这些结果(比如，后面再次调用这个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的时候)。再次运行 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时就会重用这些缓存结果。</p>
<p>要牢住上面所说的缓存行为，否则在使用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 时可能会给你造成不小的麻烦。例如，创建下面两个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> ，并对它们求值，然后释放：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
</pre></div>
</div>
<p>这就意味着相同的数据库查询将执行两次，事实上读取了两次数据库。而且，这两次读出来的列表可能并不完全相同，因为存在这种可能：在两次读取之间，某个 <tt class="docutils literal"><span class="pre">Entry</span></tt> 被添加到数据库中，或是被删除了。</p>
<p>要避免这个问题，只要简单地保存 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 然后重用即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span> <span class="c"># Evaluate the query set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span> <span class="c"># Re-use the cache from the evaluation.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-complex-lookups-with-q-objects">
<span id="s-complex-lookups-with-q"></span><span id="complex-lookups-with-q-objects"></span><span id="complex-lookups-with-q"></span><h2>用 <b>Q</b> 对象实现复杂查找 (Complex lookups with Q objects)<a class="headerlink" href="index.html#complex-lookups-with-q-objects" title="Permalink to this headline">¶</a></h2>
<p>在 <tt class="docutils literal"><span class="pre">filter()</span></tt> 等函式中关键字参数彼此之间都是 <b>&quot;AND&quot;</b> 关系。如果你要执行更复杂的查询(比如，实现筛选条件的 <tt class="docutils literal"><span class="pre">OR</span></tt> 关系)，可以使用 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象。</p>
<p> <tt class="docutils literal"><span class="pre">Q</span></tt> 对象(<tt class="docutils literal"><span class="pre">django.db.models.Q</span></tt>)是用来封装一组查询关键字的对象。这里提到的查询关键字请查看上面的 <b>&quot;Field lookups&quot;</b>。</p>
<p>例如，下面这个 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象封装了一个单独的 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 查询：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Q</span></tt> 对象可以用 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 和 <tt class="docutils literal"><span class="pre">|</span></tt> 运算符进行连接。当某个操作连接两个 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象时，就会产生一个新的等价的 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象。</p>
<p>例如，下面这段语句就产生了一个 <tt class="docutils literal"><span class="pre">Q</span></tt> ，这是用 <b>&quot;OR&quot;</b> 关系连接的两个 <tt class="docutils literal"><span class="pre">&quot;question__startswith&quot;</span></tt> 查询：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的例子等价于下面的 SQL <tt class="docutils literal"><span class="pre">WHERE</span></tt> 从句：</p>
<div class="highlight-python"><pre>WHERE question LIKE 'Who%' OR question LIKE 'What%'</pre>
</div>
<p>你可以用 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 和 <tt class="docutils literal"><span class="pre">|</span></tt> 连接任意多的 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象，而且可以用括号分组。<tt class="docutils literal"><span class="pre">Q</span></tt> 对象也可以用 <tt class="docutils literal"><span class="pre">~</span></tt> 操作取反，而且普通查询和取反查询(<tt class="docutils literal"><span class="pre">NOT</span></tt>)可以连接在一起使用：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">Q</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>每种查询函式(比如 <tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">exclude()</span></tt>, <tt class="docutils literal"><span class="pre">get()</span></tt>) 除了能接收关键字参数以外，也能以位置参数的形式接受一个或多个 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象。如果你给查询函式传递了多个 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象，那么它们彼此间都是 <b>&quot;AND&quot;</b> 关系。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p>... 大体可以翻译为下面的 SQL：</p>
<div class="highlight-python"><pre>SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')</pre>
</div>
<p>查找函式可以混用 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象和关键字参数。查询函式的所有参数(<tt class="docutils literal"><span class="pre">Q</span></tt> 关系和关键字参数) 都是 <b>&quot;AND&quot;</b> 关系。但是，如果参数中有 <tt class="docutils literal"><span class="pre">Q</span></tt> 对象，它必须排在所有的关键字参数之前。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>... 是一个有效的查询。但下面这个查询虽然看上去和前者等价：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mf">2005</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">)))</span>
</pre></div>
</div>
<p>... 但这个查询却是无效的。</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"> 在 Django 的单元测试 <a class="reference external" href="http://code.djangoproject.com/browser/django/trunk/tests/modeltests/or_lookups/models.py"> OR查询实例(OR lookups examples)</a> 中展示了 <tt class="docutils literal"><span class="pre">Q</span></tt> 的用例。</p>
</div>
</div>
<div class="section" id="s-comparing-objects">
<span id="comparing-objects"></span><h2>对象比较 (Comparing objects)<a class="headerlink" href="index.html#comparing-objects" title="Permalink to this headline">¶</a></h2>
<p>要比较两个对象，就和 Python 一样，使用双等号运算符：<tt class="docutils literal"><span class="pre">==</span></tt>。实际上比较的是两个 model 的主键值。</p>
<p>以上面的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 为例，下面两个语句是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>如果 model 的主键名称不是 <tt class="docutils literal"><span class="pre">id</span></tt>，也没关系。Django 会自动比较主键的值，而不管他们的名称是什么。例如，如果一个 model 的主键字段名称是 <tt class="docutils literal"><span class="pre">name</span></tt>，那么下面两个语句是等价的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="section" id="s-deleting-objects">
<span id="s-topics-db-queries-delete"></span><span id="deleting-objects"></span><span id="topics-db-queries-delete"></span><h2>对象删除(Deleting objects)<a class="headerlink" href="index.html#deleting-objects" title="Permalink to this headline">¶</a></h2>
<p>删除方法就是 <tt class="docutils literal"><span class="pre">delete()</span></tt>。它运行时立即删除对象而不返回任何值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>你也可以一次性删除多个对象。每个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 都有一个 <tt class="docutils literal"><span class="pre">delete()</span></tt> 方法，它一次性删除 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中所有的对象。</p>
<p>例如，下面的代码将删除 <tt class="docutils literal"><span class="pre">pub_date</span></tt> 是2005年的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>要牢记这一点：无论在什么情况下，<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的 <tt class="docutils literal"><span class="pre">delete()</span></tt> 方法都只使用一条 SQL 语句一次性删除所有对象，而并不是分别删除每个对象。如果你想使用在 model 中自定义的 <tt class="docutils literal"><span class="pre">delete()</span></tt> 方法，就要<b>自行</b>调用每个对象的<tt class="docutils literal"><span class="pre">delete</span></tt> 方法。(例如，遍历 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>，在每个对象上调用 <tt class="docutils literal"><span class="pre">delete()</span></tt>方法)，而不是使用 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的 <tt class="docutils literal"><span class="pre">delete()</span></tt>方法。</p>
<p>在 Django 删除对象时，会模仿 SQL 约束 <tt class="docutils literal"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></tt> 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="c"># This will delete the Blog and all of its Entry objects.</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>要注意的是： <tt class="docutils literal"><span class="pre">delete()</span></tt> 方法是 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 上的方法，但并不适用于 <tt class="docutils literal"><span class="pre">Manager</span></tt> 本身。这是一种保护机制，是为了避免意外地调用 <tt class="docutils literal"><span class="pre">Entry.objects.delete()</span></tt> 方法导致 <b>所有的</b> 记录被误删除。如果你<b>确认</b>要删除所有的对象，那么你必须显式地调用：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-updating-multiple-objects-at-once">
<span id="s-topics-db-queries-update"></span><span id="updating-multiple-objects-at-once"></span><span id="topics-db-queries-update"></span><h2>一次更新多个对象 (Updating multiple objects at once)<a class="headerlink" href="index.html#updating-multiple-objects-at-once" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<span class="title">这部分是 Django 1.0 中新增的：</span> <a class="reference external" href="../../../releases/1.0/index.html#releases-1-0"><em>请查看版本文档</em></a></div>
<p>有时你想对 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的所有对象，一次更新某个字段的值。这个要求可以用 <tt class="docutils literal"><span class="pre">update()</span></tt> 方法完成。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Update all the headlines with pub_date in 2007.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mf">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Everything is the same&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这种方法仅适用于<b>非关系字段</b>和 <b><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 外键字段</b>。更新非关系字段时，传入的值应该是一个常量。更新 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 字段时，传入的值应该是你想关联的那个类的某个实例。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>

<span class="go"># Change every Entry so that it belongs to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">update()</span></tt> 方法也是即时生效，不返回任何值的(与 <tt class="docutils literal"><span class="pre">delete()</span></tt> 相似)。 在 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 进行更新时，唯一的限制就是一次只能更新一个数据表，就是当前 model 的主表。所以不要尝试更新关联表和与此类似的操作，因为这是不可能运行的。</p>
<p>要小心的是： <tt class="docutils literal"><span class="pre">update()</span></tt> 方法是直接翻译成一条 SQL 语句的。因此它是直接地一次完成所有更新。它不会调用你的 model 中的 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法，也不会发出 <tt class="docutils literal"><span class="pre">pre_save</span></tt> 和 <tt class="docutils literal"><span class="pre">post_save</span></tt> 信号(这些信号在调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法时产生)。如果你想保存 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 中的每个对象，并且调用每个对象各自的 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法，那么你不必另外多写一个函式。只要遍历这些对象，依次调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法即可：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">这部分是在 Django 1.1 中新增的：</span> <a class="reference external" href="../../../releases/1.1/index.html#releases-1-1"><em>请查看版本文档</em></a></div>
<p>在调用 <b>update</b> 时可以使用 <a class="reference internal" href="index.html#query-expressions"><em>F()</em></a> 对象 来把某个字段的值更新为另一个字段的值。这对于自增记数器是非常有用的。例如，给所有的博文 (entry) 的广播数 (pingback) 加一：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n_pingbacks</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s">&#39;n_pingbacks&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<p>但是，与 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象在查询时所不同的是，在<b>filter</b> 和 <b>exclude</b>子句中，你不能在 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象中引入关联关系(NO-Join)，你只能引用当前 model 中要更新的字段。如果你在 <tt class="docutils literal"><span class="pre">F()</span></tt> 对象引入了<b>Join</b> 关系object，就会抛出 <tt class="docutils literal"><span class="pre">FieldError</span></tt> 异常：</p>
<div class="highlight-python"><pre># THIS WILL RAISE A FieldError
&gt;&gt;&gt; Entry.objects.update(headline=F('blog__name'))</pre>
</div>
</div>
<div class="section" id="s-related-objects">
<span id="related-objects"></span><h2>对象关联(Related objects)<a class="headerlink" href="index.html#related-objects" title="Permalink to this headline">¶</a></h2>
<p>当你定义在 model 定义关系时 (例如， <tt class="docutils literal"><span class="pre">ForeignKey</span></tt>,
<tt class="docutils literal"><span class="pre">OneToOneField</span></tt>, 或 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt>)，model 的实例自带一套很方便的API以获取关联的对象。</p>
<p>以最上面的 models 为例，一个 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象 <tt class="docutils literal"><span class="pre">e</span></tt> 能通过 <tt class="docutils literal"><span class="pre">blog</span></tt> 属性获得相关联的 <tt class="docutils literal"><span class="pre">Blog</span></tt> 对象：
<tt class="docutils literal"><span class="pre">e.blog</span></tt>。</p>
<p>(在场景背后，这个功能是由 Python 的 <a class="reference external" href="http://users.rcn.com/python/download/Descriptor.htm">descriptors</a> 实现的。如果你对此感兴趣，可以了解一下。)</p>
<p>Django 也提供反向获取关联对象的 API，就是由从被关联的对象得到其定义关系的主对象。例如，一个 <tt class="docutils literal"><span class="pre">Blog</span></tt> 类的实例 <tt class="docutils literal"><span class="pre">b</span></tt> 对象通过 <tt class="docutils literal"><span class="pre">entry_set</span></tt> 属性得到所有相关联的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象列表: <tt class="docutils literal"><span class="pre">b.entry_set.all()</span></tt>。</p>
<p>这一节所有的例子都使用本页顶部所列出的 <tt class="docutils literal"><span class="pre">Blog</span></tt>, <tt class="docutils literal"><span class="pre">Author</span></tt> 和 <tt class="docutils literal"><span class="pre">Entry</span></tt>
model。</p>
<div class="section" id="s-one-to-many-relationships">
<span id="one-to-many-relationships"></span><h3>一对多关系(One-to-many relationships)<a class="headerlink" href="index.html#one-to-many-relationships" title="Permalink to this headline">¶</a></h3>
<div class="section" id="s-forward">
<span id="forward"></span><h4>正向(Forward)<a class="headerlink" href="index.html#forward" title="Permalink to this headline">¶</a></h4>
<p>如果一个 model 有一个 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt>字段，我们只要通过使用关联 model 的名称就可以得到相关联的外键对象。</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="c"># Returns the related Blog object.</span>
</pre></div>
</div>
<p>你可以设置和获得外键属性。正如你所期望的，改变外键的行为并不引发数据库操作，直到你调用 <tt class="docutils literal"><span class="pre">save()</span></tt>方法时，才会保存到数据库。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>如果外键字段 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 有一个 <tt class="docutils literal"><span class="pre">null=True</span></tt> 的设置(它允许外键接受空值 <tt class="docutils literal"><span class="pre">NULL</span></tt>)，你可以赋给它空值 <tt class="xref docutils literal"><span class="pre">None</span></tt> 。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;</span>
</pre></div>
</div>
<p>在一对多关系中，第一次正向获取关联对象时，关联对象会被缓存。其后根据外键访问时这个实例，就会从缓存中获得它。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Hits the database to retrieve the associated Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
<p>要注意的是，<tt class="docutils literal"><span class="pre">QuerySet</span></tt> 的 <tt class="docutils literal"><span class="pre">select_related()</span></tt> 方法提前将所有的一对多关系放入缓存中。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Doesn&#39;t hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
</div>
<div class="section" id="s-following-relationships-backward">
<span id="s-backwards-related-objects"></span><span id="following-relationships-backward"></span><span id="backwards-related-objects"></span><h4>逆向关联(Following relationships &quot;backward&quot;)<a class="headerlink" href="index.html#following-relationships-backward" title="Permalink to this headline">¶</a></h4>
<p>如果 model 有一个 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt>外键字段，那么外联 model 的实例可以通过访问 <tt class="docutils literal"><span class="pre">Manager</span></tt> 来得到所有相关联的源 model 的实例。默认情况下，这个 <tt class="docutils literal"><span class="pre">Manager</span></tt> 被命名为 <tt class="docutils literal"><span class="pre">FOO_set</span></tt>, 这里面的 <tt class="docutils literal"><span class="pre">FOO</span></tt> 就是源 model 的小写名称。这个 <tt class="docutils literal"><span class="pre">Manager</span></tt> 返回 <tt class="docutils literal"><span class="pre">QuerySets</span></tt>，它是可过滤和可操作的，在上面 &quot;对象获取(Retrieving objects)&quot; 有提及。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entry_set is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>你可以通过在 <tt class="docutils literal"><span class="pre">ForeignKey()</span></tt> 的定义中设置 <tt class="docutils literal"><span class="pre">related_name</span></tt> 的值来覆写 <tt class="docutils literal"><span class="pre">FOO_set</span></tt> 的名称。例如，如果 <tt class="docutils literal"><span class="pre">Entry</span></tt> model 中做一下更改： <tt class="docutils literal"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">related_name='entries')</span></tt>，那么接下来就会如我们看到这般：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entries is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>你不能在一个类当中访问 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> <tt class="docutils literal"><span class="pre">Manager</span></tt> ；而必须通过类的实例来访问：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">entry_set</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager must be accessed via instance&quot;.</span>
</pre></div>
</div>
<p>除了在上面 &quot;对象获取Retrieving objects&quot; 一节中提到的 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> 方法之外，<tt class="docutils literal"><span class="pre">ForeignKey</span></tt> <tt class="docutils literal"><span class="pre">Manager</span></tt> 还有如下一些方法。下面仅仅对它们做一个简短介绍，详情请查看 <a class="reference external" href="../../../ref/models/relations/index.html#ref-models-relations"><em>related objects reference</em></a>。</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd>将某个特定的 model 对象添加到被关联对象集合中。</dd>
<dt><tt class="docutils literal"><span class="pre">create(**kwargs)</span></tt></dt>
<dd>创建并保存一个新对象，然后将这个对象加被关联对象的集合中，然后返回这个新对象。</dd>
<dt><tt class="docutils literal"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd>将某个特定的对象从被关联对象集合中去除。</dd>
<dt><tt class="docutils literal"><span class="pre">clear()</span></tt></dt>
<dd>清空被关联对象集合。</dd>
</dl>
<p>想一次指定关联集合的成员，那么只要给关联集合分配一个可迭代的对象即可。它可以包含对象的实例，也可以只包含主键的值。例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">]</span>
</pre></div>
</div>
<p>在这个例子中，<tt class="docutils literal"><span class="pre">e1</span></tt> 和 <tt class="docutils literal"><span class="pre">e2</span></tt> 可以是完整的 Entry 实例，也可以是整型的主键值。</p>
<p>如果 <tt class="docutils literal"><span class="pre">clear()</span></tt> 方法是可用的，在迭代器(上例中就是一个列表)中的对象加入到 <tt class="docutils literal"><span class="pre">entry_set</span></tt> 之前，已存在于关联集合中的所有对象将被清空。如果 <tt class="docutils literal"><span class="pre">clear()</span></tt> 方法 <b>不可用</b>，原有的关联集合中的对象就不受影响，继续存在。</p>
<p>这一节提到的每一个 <b>&quot;reverse&quot;</b> 操作都是实时操作数据库的，每一个添加，创建，删除操作都会及时保存将结果保存到数据库中。</p>
</div>
</div>
<div class="section" id="s-many-to-many-relationships">
<span id="many-to-many-relationships"></span><h3>多对多关系(Many-to-many relationships)<a class="headerlink" href="index.html#many-to-many-relationships" title="Permalink to this headline">¶</a></h3>
<p>在多对多关系的任何一方都可以使用 API 访问相关联的另一方。多对多的 API 用起来和上面提到的 <b>&quot;逆向&quot;</b> 一对多关系关系非常相象。</p>
<p>唯一的差虽就在于属性的命名： <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 所在的 model (为了方便，我称之为源model A) 使用字段本身的名称来访问关联对象；而被关联的另一方则使用 A 的小写名称加上 <tt class="docutils literal"><span class="pre">'_set'</span></tt> 后缀(这与逆向的一对多关系非常相象)。</p>
<p>下面这个例子会让人更容易理解：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Author objects for this Entry.</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Returns all Entry objects for this Author.</span>
</pre></div>
</div>
<p>与 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 一样, <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 也可以指定 <tt class="docutils literal"><span class="pre">related_name</span></tt>。在上面的例子中，如果 <tt class="docutils literal"><span class="pre">Entry</span></tt> 中的 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 指定 <tt class="docutils literal"><span class="pre">related_name='entries'</span></tt>，那么接下来每个 <tt class="docutils literal"><span class="pre">Author</span></tt> 实例的 <tt class="docutils literal"><span class="pre">entry_set</span></tt> 属性都被 <tt class="docutils literal"><span class="pre">entries</span></tt> 所代替。</p>
</div>
<div class="section" id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h3>一对一关系(One-to-one relationships)<a class="headerlink" href="index.html#one-to-one-relationships" title="Permalink to this headline">¶</a></h3>
<p>相对于多对一关系而言，一对一关系不是非常简单的。如果你在 model 中定义了一个 <a title="django.db.models.OneToOneField" class="reference external" href="../../../ref/models/fields/index.html#django.db.models.OneToOneField"><tt class="xref docutils literal"><span class="pre">OneToOneField</span></tt></a> 关系，那么你就可以用这个字段的名称做为属性来访问其所关联的对象。</p>
<p>例如：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span> <span class="c"># Returns the related Entry object.</span>
</pre></div>
</div>
<p>与 <b>&quot;reverse&quot;</b> 查询不同的是，一对一关系的关联对象也可以访问 <a title="django.db.models.Manager" class="reference external" href="../managers/index.html#django.db.models.Manager"><tt class="xref docutils literal"><span class="pre">Manager</span></tt></a> 对象，但是这个 <a title="django.db.models.Manager" class="reference external" href="../managers/index.html#django.db.models.Manager"><tt class="xref docutils literal"><span class="pre">Manager</span></tt></a> 表现一个单独的对象，而不是一个列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="c"># returns the related EntryDetail object</span>
</pre></div>
</div>
<p>如果一个空对象被赋予关联关系，Django 就会抛出一个 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常。</p>
<p>和你定义正向关联所用的方式一样，类的实例也可以赋予逆向关联方系：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
</div>
<div class="section" id="s-how-are-the-backward-relationships-possible">
<span id="how-are-the-backward-relationships-possible"></span><h3>关系中的反向连接是如何做到的？<a class="headerlink" href="index.html#how-are-the-backward-relationships-possible" title="Permalink to this headline">¶</a></h3>
<p>其他对象关系的映射(ORM)需要你在关联双方都定义关系。而 Django 的开发者则认为这违背了 <b>DRY</b> 原则 (Don't
Repeat Yourself)，所以 Django 只需要你在一方定义关系即可。</p>
<p>但仅由一个 model 类并不能知道其他 model 类是如何与它关联的，除非是其他 model 也被载入，那么这是如何办到的？</p>
<p>答案就在于 <a class="reference external" href="../../../ref/settings/index.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 设置中。任何一个 model 在第一次调用时，Django 就会遍历所有的 <a class="reference external" href="../../../ref/settings/index.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 的所有 models，并且在内存中创建中必要的反向连接。本质上来说，<a class="reference external" href="../../../ref/settings/index.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 的作用之一就是确认 Django 完整的 model 范围。</p>
</div>
<div class="section" id="s-queries-over-related-objects">
<span id="queries-over-related-objects"></span><h3>在关联对象上的查询(Queries over related objects)<a class="headerlink" href="index.html#queries-over-related-objects" title="Permalink to this headline">¶</a></h3>
<p>包含关联对象的查询与包含普通字段值的查询都遵循相同的规则。为某个查询指定某个值的时候，你可以使用一个类实例，也可以使用对象的主键值。</p>
<p>例如，如果你有一个 Blog 对象 <tt class="docutils literal"><span class="pre">b</span></tt> ，它的 <tt class="docutils literal"><span class="pre">id=5</span></tt>, 下面三个查询是一样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span> <span class="c"># Query using object instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="c"># Query using id from instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mf">5</span><span class="p">)</span> <span class="c"># Query using id directly</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-falling-back-to-raw-sql">
<span id="falling-back-to-raw-sql"></span><h2>直接使用SQL(Falling back to raw SQL)<a class="headerlink" href="index.html#falling-back-to-raw-sql" title="Permalink to this headline">¶</a></h2>
<p>如果你发现某个 SQL 查询用 Django 的数据库映射来处理会非常复杂的话，你可以使用直接写 SQL 来完成。</p>
<p>建议的方式是在你的 model 自定义方法或是自定义 model 的 manager 方法来运行查询。虽然 Django 不要求数据操作必须在 model 层中执行。但是把你的商业逻辑代码放在一个地方，从代码组织的角度来看，也是十分明智的。详情请查看 <a class="reference external" href="../sql/index.html#topics-db-sql"><em>执行原生SQL查询(Performing raw SQL queries)</em></a>.</p>
<p>最后，要注意的是，Django的数据操作层仅仅是访问数据库的一个接口。你可以用其他的工具，编程语言，数据库框架来访问数据库。对你的数据库而言，没什么是非用 Django 不可的。</p>
</div>
</div>



<div id="content-secondary">
  <h2 id="comments">Questions/Feedback</h2>
  <p>Having trouble? We'd like to help!</p>
  <ul>
    <li>
      Try the <a href="../../../faq/index.html">FAQ</a> — it's got answers to many common
      questions.
    </li>
    <li>
      Search for information in the <a
      href="http://groups.google.com/group/django-users/">archives of the
      django-users mailing list</a>, or <a
      href="http://groups.google.com/group/django-users/">post a question</a>.
    </li>
    <li>
      Ask a question in the <a href="irc://irc.freenode.net/">#django IRC
      channel</a>, or search the <a href="http://oebfare.com/logger/django/">IRC
      logs</a> to see if its been asked before.
    </li>
    <li>
      If you notice errors with this documentation, please <a
      href="http://code.djangoproject.com/simpleticket?component=Documentation">
      open a ticket</a> and let us know! Please only use the ticket tracker for
      criticisms and improvements on the docs. For tech support, use the
      resources above.
    </li>
  </ul>
</div>

		</div>
		<!-- END #content-main -->
		<div id="content-related" class="sidebar">
		
  
    <h2>Contents</h2>
    
      <ul>
<li><a class="reference external" href="index.html">Making queries</a><ul>
<li><a class="reference external" href="index.html#creating-objects">Creating objects</a></li>
<li><a class="reference external" href="index.html#saving-changes-to-objects">Saving changes to objects</a><ul>
<li><a class="reference external" href="index.html#saving-foreignkey-and-manytomanyfield-fields">Saving <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> and <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> fields</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#retrieving-objects">Retrieving objects</a><ul>
<li><a class="reference external" href="index.html#retrieving-all-objects">Retrieving all objects</a></li>
<li><a class="reference external" href="index.html#retrieving-specific-objects-with-filters">Retrieving specific objects with filters</a><ul>
<li><a class="reference external" href="index.html#id1">Chaining filters</a></li>
<li><a class="reference external" href="index.html#id2">Filtered QuerySets are unique</a></li>
<li><a class="reference external" href="index.html#id3">QuerySets are lazy</a></li>
<li><a class="reference external" href="index.html#other-queryset-methods">Other QuerySet methods</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#id4">Limiting QuerySets</a></li>
<li><a class="reference external" href="index.html#field-lookups">Field lookups</a></li>
<li><a class="reference external" href="index.html#lookups-that-span-relationships">Lookups that span relationships</a><ul>
<li><a class="reference external" href="index.html#spanning-multi-valued-relationships">Spanning multi-valued relationships</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#filters-can-reference-fields-on-the-model">Filters can reference fields on the model</a></li>
<li><a class="reference external" href="index.html#the-pk-lookup-shortcut">The pk lookup shortcut</a></li>
<li><a class="reference external" href="index.html#escaping-percent-signs-and-underscores-in-like-statements">Escaping percent signs and underscores in LIKE statements</a></li>
<li><a class="reference external" href="index.html#id5">Caching and QuerySets</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#complex-lookups-with-q-objects">Complex lookups with Q objects</a></li>
<li><a class="reference external" href="index.html#comparing-objects">Comparing objects</a></li>
<li><a class="reference external" href="index.html#deleting-objects">Deleting objects</a></li>
<li><a class="reference external" href="index.html#updating-multiple-objects-at-once">Updating multiple objects at once</a></li>
<li><a class="reference external" href="index.html#related-objects">Related objects</a><ul>
<li><a class="reference external" href="index.html#one-to-many-relationships">One-to-many relationships</a><ul>
<li><a class="reference external" href="index.html#forward">Forward</a></li>
<li><a class="reference external" href="index.html#following-relationships-backward">Following relationships &#8220;backward&#8221;</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#many-to-many-relationships">Many-to-many relationships</a></li>
<li><a class="reference external" href="index.html#one-to-one-relationships">One-to-one relationships</a></li>
<li><a class="reference external" href="index.html#how-are-the-backward-relationships-possible">How are the backward relationships possible?</a></li>
<li><a class="reference external" href="index.html#queries-over-related-objects">Queries over related objects</a></li>
</ul>
</li>
<li><a class="reference external" href="index.html#falling-back-to-raw-sql">Falling back to raw SQL</a></li>
</ul>
</li>
</ul>

    
  
  
  
    <h2>Search</h2>
    
    <form action="../../../search/index.html" id="search" class="search">
  <div>
    <input type="hidden" name="cx" value="009763561546736975936:e88ek0eurf4" />
    <input type="hidden" name="cof" value="FORID:11" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="hidden" name="hl" value="" />
    <input id="id_search_q" type="text" class="query" name="q" />
    <input type="submit" name="sa" class="submit" value="Search" />
    <ul>
<li><label for="id_search_as_q_0"><input checked="checked" type="radio" id="id_search_as_q_0" value="more:dev_docs" name="as_q" /> Latest</label></li>
<li><label for="id_search_as_q_1"><input type="radio" id="id_search_as_q_1" value="more:1.0_docs" name="as_q" /> 1.0</label></li>
<li><label for="id_search_as_q_2"><input type="radio" id="id_search_as_q_2" value="more:0.96_docs" name="as_q" /> 0.96</label></li>
<li><label for="id_search_as_q_3"><input type="radio" id="id_search_as_q_3" value="more:all_docs" name="as_q" /> All</label></li>
</ul>
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=search&amp;lang="></script>
  
  
  
    <h2>Browse</h2>
    <ul>
      
        
          <li>Prev: <a href="../models/index.html">Models</a></li>
        
        
          <li>Next: <a href="../aggregation/index.html">Aggregation</a></li>
        
        <li><a href="../../../contents/index.html">Table of contents</a></li>
        
          <li><a href="../../../genindex/index.html">General Index</a></li>
        
          <li><a href="../../../modindex/index.html">Global Module Index</a></li>
        
      
    </ul>
  
  
  
    <h2>You are here:</h2>
    <ul>
      
        <li>
          <a href="../../../index.html">Django dev documentation</a>
          
            <ul><li><a href="../../index.html">Using Django</a>
          
            <ul><li><a href="../index.html">Models and databases</a>
          
          <ul><li>Making queries</li></ul>
          </li></ul></li></ul>
        </li>
      
    </ul>
  
  
  
    <h3>Last update:</h3>
    <div>November 19, 2009, 4 p.m. (<a href="http://www.timeanddate.com/worldclock/city.html?n=64">CDT</a>)</div>
  

		</div>
		<!-- END #content-related -->

		</div>
		<!-- END #content -->
		<div id="footer">
			<p>&copy; 2005-2009 <a href="http://www.djangoproject.com/foundation/">Django Software Foundation</a> unless otherwise noted. Django is a registered trademark of the Django Software Foundation. 
			Hosting graciously provided by <a href="http://mediatemple.net/">
			<img style="vertical-align: middle; position: relative; top: -1px;" src="http://media.djangoproject.com/img/site/mt.png" alt="media temple" /></a>
			</p>
		</div>
		<!-- END #footer -->
	</div>
	<!-- END #container -->
	</body>
</html>

